<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>aochagavia&#39;s blog</title>
    <link>https://aochagavia.github.io/index.xml</link>
    <description>Recent content on aochagavia&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 12 Dec 2016 14:14:51 +0100</lastBuildDate>
    <atom:link href="https://aochagavia.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Exploring Rust&#39;s unspecified drop order</title>
      <link>https://aochagavia.github.io/blog/exploring-rusts-unspecified-drop-order/</link>
      <pubDate>Mon, 12 Dec 2016 14:14:51 +0100</pubDate>
      
      <guid>https://aochagavia.github.io/blog/exploring-rusts-unspecified-drop-order/</guid>
      <description>

&lt;p&gt;After my previous &lt;a href=&#34;https://aochagavia.github.io/blog/enforcing-drop-order-in-rust/&#34;&gt;post&lt;/a&gt;, I thought it would be
interesting to run some experiments to determine the unspecified drop order
within different constructs of Rust. After you read this, I guarantee you will
understand why there is so much &lt;a href=&#34;https://github.com/rust-lang/rfcs/issues/744&#34;&gt;discussion&lt;/a&gt; about changing
the current drop order before stabilizing it :)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TLDR:&lt;/strong&gt; the current drop order is really weird!&lt;/p&gt;

&lt;p&gt;In this post we are going to look at:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Local variables&lt;/li&gt;
&lt;li&gt;Tuples&lt;/li&gt;
&lt;li&gt;Structs and enums&lt;/li&gt;
&lt;li&gt;Slices&lt;/li&gt;
&lt;li&gt;Closure captures&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We will be reusing the &lt;code&gt;PrintDrop&lt;/code&gt; struct, so here is the definition
in case you forgot it:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;struct&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;&amp;#39;static &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;str&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;);&lt;/span&gt;

&lt;span style=&#34;color: #66d9ef&#34;&gt;impl&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Drop &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;for&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; drop(&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; self) {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        println&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;Dropping {}&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;, self.&lt;/span&gt;&lt;span style=&#34;color: #ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    }&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now we are ready to go!&lt;/p&gt;

&lt;h2 id=&#34;local-variables&#34;&gt;Local variables&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s start with the following piece of code, testing the drop order of local
variables:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; main() {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; x &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; y &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And the output is&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping y
Dropping x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, local variables are dropped in the reverse order of their
declaration. This should come as no surprise, since new objects can store
references to previously declared ones. Therefore a different drop
order would result in dangling pointers.&lt;/p&gt;

&lt;p&gt;The drop order of function parameters is similar, so the first parameter
in the list is the last one to be dropped. The code is omitted for the sake
of brevity, but this behavior can be trivially reproduced by writing a
function with two by-value parameters.&lt;/p&gt;

&lt;p&gt;If you think about drop order from the perspective of data structures, the
behavior of local variables resembles the way a stack works. You
could say that they are pushed onto the stack and popped at the
end of the scope.&lt;/p&gt;

&lt;h2 id=&#34;tuples&#34;&gt;Tuples&lt;/h2&gt;

&lt;p&gt;After seeing the stack-like behavior of local variables, one would expect to
see something similar in other constructs. However, tuples have a little
surprise for us&amp;hellip;&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; main() {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; tup &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; (PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;), PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;), PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;z&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;));&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And the output is&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping x
Dropping y
Dropping z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wait! Are you telling me that the variables are dropped in the same order as
they are declared? So it seems! To continue with the data structures story,
we could say that tuples behave like a queue, in which elements are enqueued
in their order of appearance and dequeued at the end of the scope.&lt;/p&gt;

&lt;p&gt;But this is not all! There is a subtle surprise lurking around
the corner&amp;hellip; If there is a &lt;code&gt;panic&lt;/code&gt; during construction of the tuple, the drop
order is reversed! If you don&amp;rsquo;t believe me, just run the code below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; main() {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; tup &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; (PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;), PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;), panic&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;());&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As I told you, the output is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping y
Dropping x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In other words, a tuple shows a queue-like drop order, unless one of the
expressions in the tuple constructor panics. In case
of a panic during construction, the drop order will be stack-like!&lt;/p&gt;

&lt;h2 id=&#34;structs-and-enums&#34;&gt;Structs and enums&lt;/h2&gt;

&lt;p&gt;Structs present the same weird behavior as tuples. To a certain
extent this seems consistent, since a struct is arguably a tuple with named
fields instead of indices.
It seems logical that they share the same drop order. The same holds for enums.&lt;/p&gt;

&lt;p&gt;For the sake of brevity, the code below only tests the drop order of a struct.
Of course, the same behavior is expected from tuple structs, tuple enum
variants and struct enum variants.&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;struct&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Foo {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    x&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop,&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    y&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop,&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    z&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop,&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; main() {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; foo &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Foo {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        x&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;),&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        y&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;),&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        z&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;z&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;),&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    };&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And the output is&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping x
Dropping y
Dropping z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, the order is reversed when a panic occurs during construction:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; main() {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; foo &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Foo {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        x&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;),&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        y&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;),&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        z&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; panic&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;(),&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    };&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As can be observed in the output below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping y
Dropping x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking at things from the bright side, at least we can say that this weird
behavior is consistent across all data types. Still, it feels completely
arbitrary to change the drop order when a panic occurs. This makes code that
relies on a certain drop order needlessly complex.&lt;/p&gt;

&lt;h2 id=&#34;slices&#34;&gt;Slices&lt;/h2&gt;

&lt;p&gt;Slices show the same queue-like behavior under normal circumstances and a
stack-like behavior in the presence of a panic during construction.&lt;/p&gt;

&lt;p&gt;Panic-free construction:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; main() {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; xs &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; [PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;), PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;), PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;z&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;)];&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Results in queue-like drop order:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping x
Dropping y
Dropping z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Panic during construction:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; main() {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; xs &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; [PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;), PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;), panic&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;()];&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Results in stack-like drop order:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping y
Dropping x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Interestingly, &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; shows the same drop order. As we are used to, a panic
in the &lt;code&gt;vec![]&lt;/code&gt; macro will reverse the drop order. However, if you
panic after constructing the &lt;code&gt;Vec&lt;/code&gt; by manually calling &lt;code&gt;push&lt;/code&gt; a couple of
times, the drop order will be queue-like (from Rust&amp;rsquo;s perspective
you are dropping a fully constructed &lt;code&gt;Vec&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&#34;closure-captures&#34;&gt;Closure captures&lt;/h2&gt;

&lt;p&gt;An intriguing construct to &lt;em&gt;close&lt;/em&gt; this post is the case of &lt;em&gt;closure&lt;/em&gt; captures.
We know that, under the hood, closures are actually structs that implement
the &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt; or &lt;code&gt;FnOnce&lt;/code&gt; traits. This means that the drop order depends
on the order in which captures are declared in the generated struct.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start with a simple code example. Note that the order in which the
variables are declared is different than the order in which they are used
in the closure.&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; main() {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; z &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;z&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; x &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; y &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;);&lt;/span&gt;

&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; closure &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; move &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;||&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        x; y; z;&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    };&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And the output is&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping x
Dropping y
Dropping z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Based on the output it seems that the drop order is the same as the order in
which the variables appear in the closure. However, we should test what
happens in the scenario below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; closure &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; move &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;||&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; z_ref &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;z;&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    }&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    x; y; z;&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Again, the output is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping x
Dropping y
Dropping z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, even though &lt;code&gt;z&lt;/code&gt; appears first as a reference, it is still the
last one to be dropped. Therefore we should reformulate our hypothesis and say
that the order in which captures are dropped is the same as the order in which
they are moved. This way we ignore any references that may appear before.&lt;/p&gt;

&lt;p&gt;Of course, we could perform more experiments to see if there are any edge
cases to be aware about, but in the end the best approach would be to look at
the source code of the compiler. This will certainly be necessary when drop
order is stabilized.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Enforcing drop order in Rust</title>
      <link>https://aochagavia.github.io/blog/enforcing-drop-order-in-rust/</link>
      <pubDate>Sat, 10 Dec 2016 14:14:51 +0100</pubDate>
      
      <guid>https://aochagavia.github.io/blog/enforcing-drop-order-in-rust/</guid>
      <description>

&lt;p&gt;Some days ago I stumbled upon an old &lt;a href=&#34;https://github.com/rust-lang/rfcs/issues/744&#34;&gt;issue&lt;/a&gt; on Rust&amp;rsquo;s GitHub
repository. While the title of the issue is &lt;em&gt;&amp;ldquo;should struct fields and array
elements be dropped in reverse declaration order (a la C++)&amp;rdquo;&lt;/em&gt;, the discussion
also extends to whether the current drop order should be stabilized.&lt;/p&gt;

&lt;p&gt;Surprising as it may seem, drop order in Rust is unspecified and could
theoretically be changed in the future. However, there are use cases that
require enforcing a given drop order (see, for instance, &lt;a href=&#34;http://stackoverflow.com/questions/41053542/forcing-the-order-in-which-struct-fields-are-dropped&#34;&gt;this SO
question&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;In the current version of Rust (1.13), as well as in the nightlies, there is no
mechanism to statically control the drop order of the fields of a struct.
This leaves a programmer with two options:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Wrapping fields in an &lt;code&gt;Option&lt;/code&gt;-like enum.&lt;/li&gt;
&lt;li&gt;Relying on the current (unspecified) drop order.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This post will explore how both alternatives can be used. By experimenting
with a simple problem, we will try to explain the advantages and disadvantages
of both approaches. At the end, we will also share some final thoughts on
stabilizing drop order.&lt;/p&gt;

&lt;h2 id=&#34;formulating-the-problem&#34;&gt;Formulating the problem&lt;/h2&gt;

&lt;p&gt;Before defining the problem, we need a way to monitor the drop order of
struct fields. Here, we define a struct that prints a string. It will
be used in the code examples that are to follow.&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #75715e&#34;&gt;// A struct that prints the contained `str` upon being dropped&lt;/span&gt;
&lt;span style=&#34;color: #66d9ef&#34;&gt;struct&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;&amp;#39;static &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;str&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;);&lt;/span&gt;

&lt;span style=&#34;color: #66d9ef&#34;&gt;impl&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Drop &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;for&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; drop(&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; self) {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        println&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;Dropping {}&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;, self.&lt;/span&gt;&lt;span style=&#34;color: #ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    }&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With that out of the way, here is a minimal problem to consider. Suppose you
have the following struct, and would like &lt;code&gt;baz&lt;/code&gt; to be dropped before &lt;code&gt;bar&lt;/code&gt;.
If you fail to do so, Something Bad will happen.&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;struct&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Foo {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    bar&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop,&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    baz&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop,&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&#34;alternative-one-wrapping-fields-in-an-option-like-enum&#34;&gt;Alternative one: wrapping fields in an &lt;code&gt;Option&lt;/code&gt;-like enum&lt;/h2&gt;

&lt;p&gt;Wrapping your fields is pretty straightforward if you have seen the pattern
before. For the sake of simplicity, we just use an &lt;code&gt;Option&lt;/code&gt;, though it would
be possible to write your own enum to make things a bit more ergonomic.&lt;/p&gt;

&lt;p&gt;After introducing an &lt;code&gt;Option&lt;/code&gt;, the struct looks like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;struct&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Foo {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    bar&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop,&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    baz&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Option&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;PrintDrop&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;,&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With this new struct, you can write a &lt;code&gt;Drop&lt;/code&gt; implementation that takes the
value out of the &lt;code&gt;Option&lt;/code&gt; and drops it:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;impl&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Drop &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;for&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Foo {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; drop(&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; self) {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        &lt;/span&gt;&lt;span style=&#34;color: #75715e&#34;&gt;// Drop baz by replacing it&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        self.baz &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; None;&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    }&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You can test the code by running it in a program with the following main
function:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; main() {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; foo &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Foo {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        bar&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;),&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        baz&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Some(PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;)),&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    };&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The output below shows that &lt;code&gt;baz&lt;/code&gt; is dropped first and &lt;code&gt;bar&lt;/code&gt; second, which
was exactly our intention!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping baz
Dropping bar
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;alternative-two-relying-on-the-current-unspecified-drop-order&#34;&gt;Alternative two: relying on the current (unspecified) drop order&lt;/h2&gt;

&lt;p&gt;Of course, it is also possible to find out in which order the fields are
dropped in the current version of Rust! It turns out that the fields are
dropped in the same order as they are declared.&lt;/p&gt;

&lt;p&gt;In the case of &lt;code&gt;Foo&lt;/code&gt;, this means that flipping the declaration of &lt;code&gt;baz&lt;/code&gt; and
&lt;code&gt;bar&lt;/code&gt; is exactly what we need:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;struct&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Foo {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    baz&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop,&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    bar&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop,&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;After this change, we can verify that everything works correctly by running
the code with a main function similar to our previous one. In fact, we get
the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping baz
Dropping bar
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;which-one-should-you-use&#34;&gt;Which one should you use?&lt;/h2&gt;

&lt;p&gt;In my opinion, the wrapper type is the Right Way To Go &amp;trade;, just because
you are not supposed to rely on unspecified behavior. The disadvantage of the latter approach seems
clear: a future version of the compiler implementing a different drop order
would break your program. This becomes even worse if you are authoring a
library, since a program that relies on it could potentially break just by
using a new version of the compiler. Even if you published a fix, it would
require &lt;em&gt;everyone&lt;/em&gt; to update their dependencies.&lt;/p&gt;

&lt;p&gt;On the other hand, it is undeniable that the wrapper approach has disadvantages
as well:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It is clearly less ergonomic, because you can no longer use a normal type.&lt;/li&gt;
&lt;li&gt;Each time you access the field you need to unwrap it, which means an extra
branch in your code unless the optimizer is smart enough.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;final-thoughts&#34;&gt;Final thoughts&lt;/h2&gt;

&lt;p&gt;Given the drawbacks of having to use a runtime construct to enforce
a certain drop order, it would make sense to stabilize it. While there is
clearly consensus about the need for stabilization, it is not at all clear
whether the currently implemented drop order should be changed before it is
stabilized. The discussion is still open, as summarized by nrc in a &lt;a href=&#34;https://github.com/rust-lang/rfcs/issues/744#issuecomment-231237499&#34;&gt;comment&lt;/a&gt;
on Rust&amp;rsquo;s issue tracker.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://aochagavia.github.io/about/</link>
      <pubDate>Fri, 09 Dec 2016 14:14:51 +0100</pubDate>
      
      <guid>https://aochagavia.github.io/about/</guid>
      <description>&lt;p&gt;I am a Computer Science student. I&amp;rsquo;m mostly interested in programming languages, compilers and distributed systems. As a student, I have some free time to contribute regularly to Rust, a new open source systems programming language with a fantastic community.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hello Hugo!</title>
      <link>https://aochagavia.github.io/blog/hello-hugo/</link>
      <pubDate>Fri, 09 Dec 2016 14:14:51 +0100</pubDate>
      
      <guid>https://aochagavia.github.io/blog/hello-hugo/</guid>
      <description>&lt;p&gt;A couple of months ago I shut down my old blog about programming. Although it
sounds cruel to kill a blog, the truth is that it had only one or two articles
of dubious quality.&lt;/p&gt;

&lt;p&gt;However, I think there will be interesting things to write about in the coming
months, so here I am with a new blog. After a couple of hours of tinkering
with different themes and settings, this is ready to go online! There will
be no pretexts the next time I want to write&amp;hellip; The only obstacle now is
finding time and a good topic, so stay tuned.&lt;/p&gt;

&lt;p&gt;As a fun fact, I am using Hugo to generate the website. The fact that it has
a single binary and no dependencies seems very convenient (this is not
entirely true though, since I am using &lt;code&gt;pygments&lt;/code&gt; for syntax highlighting).&lt;/p&gt;

&lt;p&gt;Anyway, now everything is in place and this post will make the blog feel
less empty until there is real content.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>