<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>aochagavia&#39;s blog</title>
    <link>https://aochagavia.github.io/index.xml</link>
    <description>Recent content on aochagavia&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 04 Jul 2017 15:14:51 +0100</lastBuildDate>
    <atom:link href="https://aochagavia.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>RFC 1857 stabilizing Rust&#39;s drop order has been accepted!</title>
      <link>https://aochagavia.github.io/blog/rfc-1857-stabilizing-rusts-drop-order-has-been-accepted/</link>
      <pubDate>Tue, 04 Jul 2017 15:14:51 +0100</pubDate>
      
      <guid>https://aochagavia.github.io/blog/rfc-1857-stabilizing-rusts-drop-order-has-been-accepted/</guid>
      <description>&lt;p&gt;If you have been following my previous posts on Rust&amp;rsquo;s drop order,
you may want to know how it all ended. In january, I summarized my
research in an RFC and submitted it for consideration of the Rust
community. Today, after six months of discussion (with around 80
replies), it has been finally accepted as &lt;a href=&#34;https://github.com/rust-lang/rfcs/blob/246ff86b320a72f98ed2df92805e8e3d48b402d6/text/1857-stabilize-drop-order.md&#34;&gt;RFC 1857&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;Besides reading the RFC itself, you may want to check my previous posts
to see the reasoning that led to it:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://aochagavia.github.io/blog/enforcing-drop-order-in-rust/&#34;&gt;Enforcing drop order&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aochagavia.github.io/blog/exploring-rusts-unspecified-drop-order/&#34;&gt;Exploring drop order&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aochagavia.github.io/blog/thoughts-on-changing-rusts-drop-order/&#34;&gt;Changing drop order&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Thoughts on changing Rust&#39;s drop order</title>
      <link>https://aochagavia.github.io/blog/thoughts-on-changing-rusts-drop-order/</link>
      <pubDate>Mon, 12 Dec 2016 15:14:51 +0100</pubDate>
      
      <guid>https://aochagavia.github.io/blog/thoughts-on-changing-rusts-drop-order/</guid>
      <description>

&lt;p&gt;There seems to be a wide consensus that the current (unspecified) drop order
in Rust is weird and arbitrary. If you are not yet convinced, you should
definitely take a look at a previous &lt;a href=&#34;https://aochagavia.github.io/blog/exploring-rusts-unspecified-drop-order/&#34;&gt;post&lt;/a&gt;
exploring the current rules.&lt;/p&gt;

&lt;p&gt;While changing the drop order seems attractive, there are many aspects that
need to be considered before embarking in such a quest. In this post I would
like to expand on the consequences of changing the drop order.&lt;/p&gt;

&lt;h2 id=&#34;an-ideal-scenario&#34;&gt;An ideal scenario&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s start with the assumption that nobody is relying at this moment on the
current drop order. That is, all library authors abide to Rust&amp;rsquo;s best practices
and there are no crates on crates.io that rely on this implementation-specific
detail. I highly doubt this is the case, but we can assume it just for the sake
of the argument (note that a crater run would be a possible way to test whether
this assumption holds).&lt;/p&gt;

&lt;p&gt;Suppose you are writing a library which internally uses
&lt;code&gt;unsafe&lt;/code&gt;, but exposes a safe interface. When figuring out how to expose said
interface, you realize that you need to drop the fields in one of your structs
in a specific order. Otherwise you are treading into the realms of Undefined
Behavior.&lt;/p&gt;

&lt;p&gt;Fortunately, there has just been an RFC that changes Rust&amp;rsquo;s current drop order
to something sane. It is even stable! Of course, you decide to use it. Much
better than relying on the unergonomic workarounds we have been using up to
this moment.&lt;/p&gt;

&lt;h2 id=&#34;breakage&#34;&gt;Breakage&lt;/h2&gt;

&lt;p&gt;The scenario described before seems to be ideal. However, the library would
silently break if compiled with an old enough compiler. That is, in case you
are using a compiler that knows nothing about the new drop order, the library
will trigger undefined behavior.&lt;/p&gt;

&lt;p&gt;The issue here is that the drop order depends on the version of the compiler,
but there is nothing in the code that gives a hint about which order should
be used. Furthermore, as a library author, you don&amp;rsquo;t know which compiler will
be used by your clients, which means that you cannot trust on a given drop
order.&lt;/p&gt;

&lt;h2 id=&#34;a-partial-solution&#34;&gt;A partial solution&lt;/h2&gt;

&lt;p&gt;Any solution requires coming up with a way to ensure old compilers
reject the new code. For instance, we could require a crate attribute like
&lt;code&gt;#![stable_drop_order]&lt;/code&gt;. This way, an old compiler would fail with the
following error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The attribute `stable_drop_order` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Problem solved? No way&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;back-to-the-beginning&#34;&gt;Back to the beginning&lt;/h2&gt;

&lt;p&gt;Even with the new crate attribute in place, there is still an
unanswered question: what happens if a programmer forgets to add the necessary
attribute? Which drop order would be used then? As you can see, we get the
same undesirable situation as today: the default drop order is still
unspecified and unstable.&lt;/p&gt;

&lt;p&gt;In fact, you end up with two different drop orders. An official one, which can
be activated on a per-crate basis by using a special attribute; and an
unspecified one, which &amp;ldquo;should not be used&amp;rdquo; but is still there.&lt;/p&gt;

&lt;p&gt;This situation would probably lead to a de facto stabilization of the
unspecified drop order. Other implementations of Rust would be forced
to copy it to avoid accidentally breaking code.&lt;/p&gt;

&lt;p&gt;The conclusion is clear: even if we introduce a sane drop order, the current
drop order needs to be stabilized anyway. It a pity, but I think
there is no way around it. I would really love to be proven wrong.&lt;/p&gt;

&lt;h2 id=&#34;a-possible-compromise&#34;&gt;A possible compromise&lt;/h2&gt;

&lt;p&gt;While I think that stabilizing the current drop order is the way to go,
there is still an alternative that could be considered. Namely, if a
library did not opt in to the new drop order (by using the
&lt;code&gt;#![stable_drop_order]&lt;/code&gt; attribute), the new compiler could assume that
the author meant to use the new drop order anyway.&lt;/p&gt;

&lt;p&gt;This way, we solve the problem described in the previous section, since there is no
longer an unspecified drop order. Furthermore, forgetting to add the attribute
would be considered a bug in the library and should be fixed by the author.&lt;/p&gt;

&lt;p&gt;However, there are two big counter arguments for this compromise:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It is too easy to forget adding said crate attribute. It could become a very
effective footgun.&lt;/li&gt;
&lt;li&gt;If there is &lt;em&gt;any&lt;/em&gt; crate out there relying on the current drop order, it will silently
break when updating to a recent compiler.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The latter problem could be treated as a library bug as well. However, the
fact that the bug would only be reproducible in some versions of the compiler
makes it particularly pernicious. You would need to be very picky about
picking your dependencies after updating to a recent compiler.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;As you probably noticed, I am in favor of stabilizing the current drop order.
Once this happens, we could start thinking about introducing an alternative
opt-in drop order. However, the concrete details are subject of a different
discussion.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exploring Rust&#39;s unspecified drop order</title>
      <link>https://aochagavia.github.io/blog/exploring-rusts-unspecified-drop-order/</link>
      <pubDate>Mon, 12 Dec 2016 14:14:51 +0100</pubDate>
      
      <guid>https://aochagavia.github.io/blog/exploring-rusts-unspecified-drop-order/</guid>
      <description>

&lt;p&gt;After my previous &lt;a href=&#34;https://aochagavia.github.io/blog/enforcing-drop-order-in-rust/&#34;&gt;post&lt;/a&gt;, I thought it would be
interesting to run some experiments to determine the unspecified drop order
within different constructs of Rust. After you read this, I guarantee you will
understand why there is so much &lt;a href=&#34;https://github.com/rust-lang/rfcs/issues/744&#34;&gt;discussion&lt;/a&gt; about changing
the current drop order before stabilizing it :)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TLDR:&lt;/strong&gt; the current drop order is really weird!&lt;/p&gt;

&lt;p&gt;In this post we are going to look at:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Local variables&lt;/li&gt;
&lt;li&gt;Tuples&lt;/li&gt;
&lt;li&gt;Structs and enums&lt;/li&gt;
&lt;li&gt;Slices&lt;/li&gt;
&lt;li&gt;Closure captures&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We will be reusing the &lt;code&gt;PrintDrop&lt;/code&gt; struct, so here is the definition
in case you forgot it:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;struct&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;&amp;#39;static &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;str&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;);&lt;/span&gt;

&lt;span style=&#34;color: #66d9ef&#34;&gt;impl&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Drop &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;for&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; drop(&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; self) {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        println&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;Dropping {}&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;, self.&lt;/span&gt;&lt;span style=&#34;color: #ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    }&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now we are ready to go!&lt;/p&gt;

&lt;h2 id=&#34;local-variables&#34;&gt;Local variables&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s start with the following piece of code, testing the drop order of local
variables:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; main() {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; x &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; y &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And the output is&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping y
Dropping x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, local variables are dropped in the reverse order of their
declaration. This should come as no surprise, since new objects can store
references to previously declared ones. Therefore a different drop
order would result in dangling pointers.&lt;/p&gt;

&lt;p&gt;The drop order of function parameters is similar, so the first parameter
in the list is the last one to be dropped. The code is omitted for the sake
of brevity, but this behavior can be trivially reproduced by writing a
function with two by-value parameters.&lt;/p&gt;

&lt;p&gt;If you think about drop order from the perspective of data structures, the
behavior of local variables resembles the way a stack works. You
could say that they are pushed onto the stack and popped at the
end of the scope.&lt;/p&gt;

&lt;h2 id=&#34;tuples&#34;&gt;Tuples&lt;/h2&gt;

&lt;p&gt;After seeing the stack-like behavior of local variables, one would expect to
see something similar in other constructs. However, tuples have a little
surprise for us&amp;hellip;&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; main() {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; tup &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; (PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;), PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;), PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;z&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;));&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And the output is&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping x
Dropping y
Dropping z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wait! Are you telling me that the variables are dropped in the same order as
they are declared? So it seems! To continue with the data structures story,
we could say that tuples behave like a queue, in which elements are enqueued
in their order of appearance and dequeued at the end of the scope.&lt;/p&gt;

&lt;p&gt;But this is not all! There is a subtle surprise lurking around
the corner&amp;hellip; If there is a &lt;code&gt;panic&lt;/code&gt; during construction of the tuple, the drop
order is reversed! If you don&amp;rsquo;t believe me, just run the code below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; main() {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; tup &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; (PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;), PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;), panic&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;());&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As I told you, the output is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping y
Dropping x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In other words, a tuple shows a queue-like drop order, unless one of the
expressions in the tuple constructor panics. In case
of a panic during construction, the drop order will be stack-like!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EDIT:&lt;/strong&gt; as pointed out by &lt;a href=&#34;https://www.reddit.com/r/rust/comments/5hw00k/exploring_rusts_unspecified_drop_order/db3ejx0/&#34;&gt;birkenfeld&lt;/a&gt; on Reddit, the stack-like
drop order actually makes sense in case of a panic. There is at this stage no tuple!
Therefore, the expressions are dropped according to the rules of local variables.&lt;/p&gt;

&lt;h2 id=&#34;structs-and-enums&#34;&gt;Structs and enums&lt;/h2&gt;

&lt;p&gt;Structs present the same weird behavior as tuples. To a certain
extent this seems consistent, since a struct is arguably a tuple with named
fields instead of indices.
It seems logical that they share the same drop order. The same holds for enums.&lt;/p&gt;

&lt;p&gt;For the sake of brevity, the code below only tests the drop order of a struct.
Of course, the same behavior is expected from tuple structs, tuple enum
variants and struct enum variants.&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;struct&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Foo {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    x&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop,&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    y&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop,&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    z&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop,&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; main() {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; foo &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Foo {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        x&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;),&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        y&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;),&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        z&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;z&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;),&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    };&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And the output is&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping x
Dropping y
Dropping z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, the order is reversed when a panic occurs during construction:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; main() {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; foo &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Foo {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        x&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;),&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        y&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;),&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        z&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; panic&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;(),&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    };&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As can be observed in the output below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping y
Dropping x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking at things from the bright side, at least we can say that this
behavior is consistent across all data types. Still, it feels completely
arbitrary to use a queue-like drop order.&lt;/p&gt;

&lt;h2 id=&#34;slices&#34;&gt;Slices&lt;/h2&gt;

&lt;p&gt;Slices show the same queue-like behavior under normal circumstances and a
stack-like behavior in the presence of a panic during construction.&lt;/p&gt;

&lt;p&gt;Panic-free construction:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; main() {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; xs &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; [PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;), PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;), PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;z&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;)];&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Results in queue-like drop order:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping x
Dropping y
Dropping z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Panic during construction:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; main() {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; xs &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; [PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;), PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;), panic&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;()];&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Results in stack-like drop order:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping y
Dropping x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Interestingly, &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; shows the same drop order. As we are used to, a panic
in the &lt;code&gt;vec![]&lt;/code&gt; macro will reverse the drop order. However, if you
panic after constructing the &lt;code&gt;Vec&lt;/code&gt; by manually calling &lt;code&gt;push&lt;/code&gt; a couple of
times, the drop order will be queue-like (from Rust&amp;rsquo;s perspective
you are dropping a fully constructed &lt;code&gt;Vec&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&#34;closure-captures&#34;&gt;Closure captures&lt;/h2&gt;

&lt;p&gt;An intriguing construct to &lt;em&gt;close&lt;/em&gt; this post is the case of &lt;em&gt;closure&lt;/em&gt; captures.
We know that, under the hood, closures are actually structs that implement
the &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt; or &lt;code&gt;FnOnce&lt;/code&gt; traits. This means that the drop order depends
on the order in which captures are declared in the generated struct.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start with a simple code example. Note that the order in which the
variables are declared is different than the order in which they are used
in the closure.&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; main() {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; z &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;z&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; x &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; y &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;);&lt;/span&gt;

&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; closure &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; move &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;||&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        x; y; z;&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    };&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And the output is&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping x
Dropping y
Dropping z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Based on the output it seems that the drop order is the same as the order in
which the variables appear in the closure. However, we should test what
happens in the scenario below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; closure &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; move &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;||&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; z_ref &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;z;&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    }&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    x; y; z;&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Again, the output is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping x
Dropping y
Dropping z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, even though &lt;code&gt;z&lt;/code&gt; appears first as a reference, it is still the
last one to be dropped. Therefore we should reformulate our hypothesis and say
that the order in which captures are dropped is the same as the order in which
they are moved. This way we ignore any references that may appear before.&lt;/p&gt;

&lt;p&gt;Of course, we could perform more experiments to see if there are any edge
cases to be aware about, but in the end the best approach would be to look at
the source code of the compiler. This will certainly be necessary when drop
order is stabilized.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Enforcing drop order in Rust</title>
      <link>https://aochagavia.github.io/blog/enforcing-drop-order-in-rust/</link>
      <pubDate>Sat, 10 Dec 2016 14:14:51 +0100</pubDate>
      
      <guid>https://aochagavia.github.io/blog/enforcing-drop-order-in-rust/</guid>
      <description>

&lt;p&gt;Some days ago I stumbled upon an old &lt;a href=&#34;https://github.com/rust-lang/rfcs/issues/744&#34;&gt;issue&lt;/a&gt; on Rust&amp;rsquo;s GitHub
repository. While the title of the issue is &lt;em&gt;&amp;ldquo;should struct fields and array
elements be dropped in reverse declaration order (a la C++)&amp;rdquo;&lt;/em&gt;, the discussion
also extends to whether the current drop order should be stabilized.&lt;/p&gt;

&lt;p&gt;Surprising as it may seem, drop order in Rust is unspecified and could
theoretically be changed in the future. However, there are use cases that
require enforcing a given drop order (see, for instance, &lt;a href=&#34;http://stackoverflow.com/questions/41053542/forcing-the-order-in-which-struct-fields-are-dropped&#34;&gt;this SO
question&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;In the current version of Rust (1.13), as well as in the nightlies, there is no
mechanism to statically control the drop order of the fields of a struct.
This leaves a programmer with two options:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Wrapping fields in an &lt;code&gt;Option&lt;/code&gt;-like enum.&lt;/li&gt;
&lt;li&gt;Relying on the current (unspecified) drop order.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This post will explore how both alternatives can be used. By experimenting
with a simple problem, we will try to explain the advantages and disadvantages
of both approaches. At the end, we will also share some final thoughts on
stabilizing drop order.&lt;/p&gt;

&lt;h2 id=&#34;formulating-the-problem&#34;&gt;Formulating the problem&lt;/h2&gt;

&lt;p&gt;Before defining the problem, we need a way to monitor the drop order of
struct fields. Here, we define a struct that prints a string. It will
be used in the code examples that are to follow.&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #75715e&#34;&gt;// A struct that prints the contained `str` upon being dropped&lt;/span&gt;
&lt;span style=&#34;color: #66d9ef&#34;&gt;struct&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;&amp;#39;static &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;str&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;);&lt;/span&gt;

&lt;span style=&#34;color: #66d9ef&#34;&gt;impl&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Drop &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;for&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; drop(&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; self) {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        println&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;Dropping {}&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;, self.&lt;/span&gt;&lt;span style=&#34;color: #ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    }&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With that out of the way, here is a minimal problem to consider. Suppose you
have the following struct, and would like &lt;code&gt;baz&lt;/code&gt; to be dropped before &lt;code&gt;bar&lt;/code&gt;.
If you fail to do so, Something Bad will happen.&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;struct&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Foo {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    bar&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop,&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    baz&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop,&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&#34;alternative-one-wrapping-fields-in-an-option-like-enum&#34;&gt;Alternative one: wrapping fields in an &lt;code&gt;Option&lt;/code&gt;-like enum&lt;/h2&gt;

&lt;p&gt;Wrapping your fields is pretty straightforward if you have seen the pattern
before. For the sake of simplicity, we just use an &lt;code&gt;Option&lt;/code&gt;, though it would
be possible to write your own enum to make things a bit more ergonomic.&lt;/p&gt;

&lt;p&gt;After introducing an &lt;code&gt;Option&lt;/code&gt;, the struct looks like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;struct&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Foo {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    bar&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop,&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    baz&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Option&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;PrintDrop&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;,&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With this new struct, you can write a &lt;code&gt;Drop&lt;/code&gt; implementation that takes the
value out of the &lt;code&gt;Option&lt;/code&gt; and drops it:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;impl&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Drop &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;for&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Foo {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; drop(&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;mut&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; self) {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        &lt;/span&gt;&lt;span style=&#34;color: #75715e&#34;&gt;// Drop baz by replacing it&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        self.baz &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; None;&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    }&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You can test the code by running it in a program with the following main
function:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; main() {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;let&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; foo &lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Foo {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        bar&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;),&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;        baz&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Some(PrintDrop(&lt;/span&gt;&lt;span style=&#34;color: #e6db74&#34;&gt;&amp;quot;baz&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt;)),&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    };&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The output below shows that &lt;code&gt;baz&lt;/code&gt; is dropped first and &lt;code&gt;bar&lt;/code&gt; second, which
was exactly our intention!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping baz
Dropping bar
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;alternative-two-relying-on-the-current-unspecified-drop-order&#34;&gt;Alternative two: relying on the current (unspecified) drop order&lt;/h2&gt;

&lt;p&gt;Of course, it is also possible to find out in which order the fields are
dropped in the current version of Rust! It turns out that the fields are
dropped in the same order as they are declared.&lt;/p&gt;

&lt;p&gt;In the case of &lt;code&gt;Foo&lt;/code&gt;, this means that flipping the declaration of &lt;code&gt;baz&lt;/code&gt; and
&lt;code&gt;bar&lt;/code&gt; is exactly what we need:&lt;/p&gt;
&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #66d9ef&#34;&gt;struct&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; Foo {&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    baz&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop,&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;    bar&lt;/span&gt;&lt;span style=&#34;color: #f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color: #f8f8f2&#34;&gt; PrintDrop,&lt;/span&gt;
&lt;span style=&#34;color: #f8f8f2&#34;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;After this change, we can verify that everything works correctly by running
the code with a main function similar to our previous one. In fact, we get
the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Dropping baz
Dropping bar
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;which-one-should-you-use&#34;&gt;Which one should you use?&lt;/h2&gt;

&lt;p&gt;In my opinion, the wrapper type is the Right Way To Go &amp;trade;, just because
you are not supposed to rely on unspecified behavior. The disadvantage of the latter approach seems
clear: a future version of the compiler implementing a different drop order
would break your program. This becomes even worse if you are authoring a
library, since a program that relies on it could potentially break just by
using a new version of the compiler. Even if you published a fix, it would
require &lt;em&gt;everyone&lt;/em&gt; to update their dependencies.&lt;/p&gt;

&lt;p&gt;On the other hand, it is undeniable that the wrapper approach has disadvantages
as well:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It is clearly less ergonomic, because you can no longer use a normal type.&lt;/li&gt;
&lt;li&gt;Each time you access the field you need to unwrap it, which means an extra
branch in your code unless the optimizer is smart enough.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;final-thoughts&#34;&gt;Final thoughts&lt;/h2&gt;

&lt;p&gt;Given the drawbacks of having to use a runtime construct to enforce
a certain drop order, it would make sense to stabilize it. While there is
clearly consensus about the need for stabilization, it is not at all clear
whether the currently implemented drop order should be changed before it is
stabilized. The discussion is still open, as summarized by nrc in a &lt;a href=&#34;https://github.com/rust-lang/rfcs/issues/744#issuecomment-231237499&#34;&gt;comment&lt;/a&gt;
on Rust&amp;rsquo;s issue tracker.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://aochagavia.github.io/about/</link>
      <pubDate>Fri, 09 Dec 2016 14:14:51 +0100</pubDate>
      
      <guid>https://aochagavia.github.io/about/</guid>
      <description>&lt;p&gt;I am a Computer Science student. I&amp;rsquo;m mostly interested in programming languages, compilers and distributed systems. As a student, I have some free time to contribute regularly to Rust, a new open source systems programming language with a fantastic community.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hello Hugo!</title>
      <link>https://aochagavia.github.io/blog/hello-hugo/</link>
      <pubDate>Fri, 09 Dec 2016 14:14:51 +0100</pubDate>
      
      <guid>https://aochagavia.github.io/blog/hello-hugo/</guid>
      <description>&lt;p&gt;A couple of months ago I shut down my old blog about programming. Although it
sounds cruel to kill a blog, the truth is that it had only one or two articles
of dubious quality.&lt;/p&gt;

&lt;p&gt;However, I think there will be interesting things to write about in the coming
months, so here I am with a new blog. After a couple of hours of tinkering
with different themes and settings, this is ready to go online! There will
be no pretexts the next time I want to write&amp;hellip; The only obstacle now is
finding time and a good topic, so stay tuned.&lt;/p&gt;

&lt;p&gt;As a fun fact, I am using Hugo to generate the website. The fact that it has
a single binary and no dependencies seems very convenient (this is not
entirely true though, since I am using &lt;code&gt;pygments&lt;/code&gt; for syntax highlighting).&lt;/p&gt;

&lt;p&gt;Anyway, now everything is in place and this post will make the blog feel
less empty until there is real content.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>